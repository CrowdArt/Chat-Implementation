It always starts with intents. Intents are the trunking joints of the dialogue tree. It connects all of the branches. Intents determine where conversation will go and what an agent should do. In communication, intents can be thought of as the root verbs in the dialogue, such as wanting coffee translating to acquiring a beverage. Sometimes, being intents are not explicit and instead are inferred from the entire composition of a phrase. You want to map your intents to the goal of your obligation. If you're a help desk application, then your intents might include opening or filing a ticket, updating a ticket, closing a ticket. But your application may also need to access and update a user's account information, range over to a live technician, and even pass a longer quality assurance survey. Even affirmation, answering yes or no, is an intent. Intents evolve as your understanding of the users' needs evolves. You may find yourself doubling or tripling your intents beyond the draft side of intents. To make the task of defining intents easier, some rules of thumb can be applied. First, identify the verbs in the dialogue people will have with your agent. Doing that will allow your agent to have its actions mapped to needs from the user. Another possible scenario is to identify where the application should branch logic. Here's some examples. "Two mocha coffees please." "How many calories in a slice?" "I want a pizza" Or even, "I really need some caffeine." Once you have chosen your intents, you need to train your agent to recognize them. This can be done with the use of training phrases. The training phrases for each intent should be representative of how users manifest such intent. It is always a good idea to add variations to the grammatical construction of a request, using passive versus active voices, questions versus statements, and etc. When creating an intent, the more training phrases you can think of, the better. Later, we will discuss best practices for writing your training phrases. Let's do a quick activity. Can you come up with at least 10 different ways of ordering pizza? Your training phrases can be generic. I want a pizza. Which specific? Can I have a slice of pepperoni pizza? Needless to say, you could even add details such as the type of crust. It all depends on your use case. Take a few seconds to think about it. Here are some examples of additional training phrases. I will use these examples when I create my pizza-ordering intent in the Dialogflow console. Let's see how we can do that. All right. So, here's the dialogue for console. You can get here by going to console.dialogflow.com. As you can see, the left sidebar contains a menu with many options. I have already gone ahead and created my agent called agent one. Now, I'm ready to set up my intents. On the intents page, we can create new intents. By clicking create intent, we can choose a name for our intent. I'm going to choose order.pizza for the example we've been discussing. Scrolling down to the training phrases, click add training phrase. Here, you can enter the examples we've talked about. So, I would say, ''Can we have a pizza, please?'' Or, ''I would like to order a pizza now.'' Once you answered all of the training phrases, you can click the save button. You'll notice that the agent will start training once you introduce changes to it. If you want to test any other changes that you made, wait until the training is completed, and then test your agent. So, now, I'm going to go ahead and switch to another agent, which I have already added more training phrases, and that's agent two. So, if you see here, we have a larger list of training phrases that I entered and saved. I'm going to click save again, just to have my agent trained.

#
So far, you've learned about creating intents and using training phrases to teach the agent how to recognize these intents. But let's say that you want to enable your agent to extract a specific pieces of information provided by the user. For example, the toppings they want on the pizza they are ordering or the number of slices. You can do that with entities. Entities help you get to the specifics of an interaction. In dialogue, the entities are the nouns or quantifiers found through the conversation, such as a person's name, the food in a review of a cruise, specific numbers, dates, just to name a few. In the case of ordering pizza, pizza would be a grouping of attributes that can be seen as entities. Pizza ordering have as attributes, number of pizzas, toppings, type of crust, pickup or delivery time. When you are designing your entity groupings, you need to know how granular the entities should get. Sometimes, simply pizza is sufficient, but sometimes you need to know finer details. Entities help your agent decide what details he needs to know and how we should act based on those details. Entities are also a great way to add personalization to an agent. You can use an entity in data, as stored in a database, to remember details about a user such as their name, or favor order, you can then echo those details back, turning a rigid conversation intro casual dialogue. Entities usually are the nouns in your dialogue. They're commonly composed of root terms in their synonyms. For the example in the yellow box, someone could say veggie or vegetarian, and this should map to the same entity representing the toppings of the pizza. Let's see how we can create entities in the Dialogflow console. So, I'm back in the Dialogflow console. To create a new entity in Dialogflow, click on the Entities page, then click Create Entity. Choose a name for your entity. I'm going to call this pizza_topping. You'll see two options, one is defined synonyms which is checked by default, the other one is allow automated expansion. Right now let's look at the defined synonyms option. When you click to edit an entry, you can then choose the first term to describe your topping, so, let's choose cheese. When you hit tab, you see that cheese is already added as a synonym for the reference value. I won't add any more examples here because people usually only refer to a cheese topping by seeing door cheese. But let's say I decide to add the vegetarian option. For that, I will probably would want to add the veggie synonym, as people might refer to that topping as veggie as well. Click Save. We might want to have a couple more examples here, so, let me switch to an agent that I already prepared, that has a larger list of entities for our pizza_topping. So, you see here, the pizza_topping entity? That's my list. You see that I have bacon, and I added as synonyms, bacon pieces, bacon bytes, or bacon slices. I have jalapenos where added jalapenos or hot peppers. The same way, you are going to think of all of the toppings that your pizza place carries and then add in here. Now let's take a look at the allow automated expansion option. Allow automated expansion is when we want to allow the agent to accept other reference values that may be said by the user or are not added to the list initially. Let's say a user wants tomatoes on the pizza. If the allow automated expansion is checked, then, when they order the pizza and they mention tomato, even though it is not here, tomato it is going to be added to the list, and the agent will be able to identify that intent the same way. But if you want to fix set of options and you do not want to allow new ones to be added to your list, then you should not check this option.
4:44
So, now we're ready to annotate our intent training phrases with the entities we just created. To do that, let's go back to our order pizza intent and once we have the list of training phrases, we're going to double-click on the word that we want to annotate. So, let's annotate the phrase, "I wanted pizza with mushroom bacon cheese." So, you'll double-click mushroom, and you'll see a list of entities that pops up. Scroll down and look for the one that we just created.
5:23
The list seems so long. You can filter the option as well. You can say pizza_topping and then it's going to show. Once you click it, you'll see that now the term mushroom is annotated with the pizza_topping entity. We're going to do the same with bacon. Now, you see that is the first one in the list. So, just choose it, do the same for cheese, and that's it. We just annotated all of the toppings in that example. Again, now I'm going to save it and switch to another one, another agent that already has all of the training phrases annotated with our pizza_topping example.
6:12
Click order pizza, and there you have it. So, we see that all of our toppings are properly annotated. Now, let me show you what happens if you decide to add one more training phrase to your intent. Let's come here and type, "I would like to order a beef, sausage, and pepperoni pizza. Once I hit Enter, you're going notice that all three entities they are present in the training phrase, were probably annotated as a pizza_topping without me having to go there and modify it or annotate it. If you do however notice that the agent did not automatically annotate something, you can then go and fix the annotation yourself. Notice that the agent automatically annotates towards the match entity reference values. You may be asking them, why don't we create entities before adding training phrases? That's totally reasonable, and you'll get to that when you try the hands-on lab. When you're creating an entity and you identify that the entity contains attributes they need to map to, one way is to use composite entities. For our ordering pizza example, let's say that we want to create an intent for ordering drinks. A drink can be of type milkshake or smoothie. Milkshake and smoothie in this case, are entries in an entity called drink. Additionally, let's say we have different flavors and milk types that can be chosen for the drinks. In this scenario, we might want to use composite entities to allow the agent to identify these attributes when the user requests. Can I have a non-fat is strawberry milkshake? For this case, create separate entities from milk type, listing all of the milk types your business carries in a separate entity for flavor. Then combine those under an entity, here we call it drink composite. That shows the different ways customers can ask for the drink and it's attributes. For the pizza order use case, let's say that the user wants to determine the time they want to pick up their order. In that case, when they say the time, the agent should be able to identify and extract the time as in the standard format, ISO for example. So, you can communicate the time to the back-end system responsible for the orders. Similarly, sometimes we need to identify common concepts such as dates, addresses, phone numbers, given names. For that, instead of defining integers for things such as days of the week or months of the year, use one of the system entities that represent date and time. System entities are pre-built entities provided by Dialogflow in order to facilitate handling the most popular concepts such as addresses, currency, units date, time, and many others. Do you see any system entities that could be used in our pizza ordering event? Let's check it out. In the training phrases we have so far, we can annotate the number of pizzas, one, and the time the user wants the pizza to be prepared for pick up, like now in this example. So, let's double-click on one.
9:56
As we see here, the list of entities appear and we want a number to be the one for one, the number of slices.
10:11
Now, we want that to be time. So, we choose sys.time. You notice that the system entities are preceded by the @sys, and that is to differentiate them from the developer entities. Don't forget to click Save. Up to this point, we've looked at composite entities and system entities individually, but what about system composite entities? For example, if the user says €200, Dialogflow returns an object type value consisting of two attribute value pairs, amount and currency. Visit the reference section at the end of this module to find the documentation of all of these system entities currently supported. When creating entities, there is a few things to keep in mind to make sure we are training our agent well. First, it is important to be consistent when annotating the entities in the training phrases. This will help the agent to not get confused about what should be recognized as a given entity. Note, then in some cases, they have included at and for. Being careful to not add stop words such as propositions is extremely important. Make sure you provide diversification of examples of a given entity in your training phrase. This allow the agent to understand that the concept is part of an intent as opposed to an instance of the concept alone. On this example, providing only Taurus will not be enough to teach the age, and that the same should apply to order constellations as well.
